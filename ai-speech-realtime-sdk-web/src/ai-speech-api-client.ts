/* tslint:disable */

/*
 ** Copyright (c) 2024, 2025, Oracle and/or its affiliates.
 ** Licensed under the Universal Permissive License v 1.0 as shown at https://oss.oracle.com/licenses/upl/
 */

/**
 * Speech API
 * The OCI Speech Service harnesses the power of spoken language by allowing developers to easily convert file-based data containing human speech into highly accurate text transcriptions.
 *
 * OpenAPI spec version: 20220101
 *
 *
 * NOTE: This class is auto generated by the swagger code generator program.
 * https://github.com/swagger-api/swagger-codegen.git
 * Do not edit the class manually.
 */

/**
 * Request sent to the realtime authentication endpoint in order to obtain the auth token.
 */
export interface CreateRealtimeSessionTokenDetails {
  /**
   * The [OCID](/iaas/Content/General/Concepts/identifiers.htm) of the compartment where you want to create the job.
   */
  compartmentId: string;
  /**
   * Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{\"bar-key\": \"value\"}`.
   */
  freeformTags?: { [key: string]: string };
  /**
   * Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{\"foo-namespace-1\": {\"bar-key-1\": \"value-1\", \"bar-key-2\": \"value-2\"}, \"foo-namespace-2\": {\"bar-key-1\": \"value-1\", \"bar-key-2\": \"value-2\"}}`.
   */
  definedTags?: { [key: string]: { [key: string]: any } };
}

/**
 * Inference payload for using Customization in Realtime Speech or Async Speech
 */
export interface CustomizationInference {
  /**
   * The [OCID](/iaas/Content/General/Concepts/identifiers.htm) of the customization to use.
   */
  customizationId?: string;
  /**
   * Alias of the customization
   */
  customizationAlias?: string;
  /**
   * The [OCID](/iaas/Content/General/Concepts/identifiers.htm) of the compartment where customization is present
   */
  compartmentId?: string;
  /**
   * Entities present in the customization
   */
  entities?: Array<CustomizationInferenceEntity>;
}

/**
 * Entity Object for customization inference payload
 */
export interface CustomizationInferenceEntity {
  /**
   * Entity type
   */
  entityType?: string;
  /**
   * The [OCID](/iaas/Content/General/Concepts/identifiers.htm) of the customization to use.
   */
  customizationId?: string;
  /**
   * Alias of the customization
   */
  customizationAlias?: string;
}

/**
 * Websocket messages sent between client and service.
 */
export interface RealtimeMessage {
  /**
   * Incoming Types of message event sent from Service -> Client - RESULT - result - ACKAUDIO - ackAudio - ERROR - error - CONNECT - connect Outgoing Types of message event sent from Client -> Service - SEND_FINAL_RESULT - sendFinalResult
   */
  event: RealtimeMessageEventEnum;
  /**
   * Session ID for the connected session.
   */
  sessionId?: string;
}

export type RealtimeMessageEventEnum = "RESULT" | "ACKAUDIO" | "ERROR" | "CONNECT";
/**
 * Details object for the websocket ack message received from service.
 */
export interface RealtimeMessageAckAudioDetails {
  /**
   * Sequence number of the acknowledged packet.
   */
  number: number;
  /**
   * Offset of the acknowledged packet.
   */
  offset: number;
  /**
   * Length in bytes of the acknowledged packet.
   */
  length: number;
}

/**
 * The payload for authentication.
 */
export interface RealtimeMessageAuthentication {
  /**
   * Type of authentication method to be used.
   */
  authenticationType: RealtimeMessageAuthenticationAuthenticationTypeEnum;
  /**
   * Compartment ID to be used for authentication/authorization.
   */
  compartmentId: string;
}

export type RealtimeMessageAuthenticationAuthenticationTypeEnum = "CREDENTIALS" | "TOKEN";
/**
 * Websocket messages sent by client to the service.
 */
export interface RealtimeMessageOut {
  /**
   * Outgoing Types of message event sent from Client -> Service - SEND_FINAL_RESULT - sendFinalResult
   */
  event: RealtimeMessageOutEventEnum;
}

export enum RealtimeMessageOutEventEnum {
  SEND_FINAL_RESULT = "SEND_FINAL_RESULT",
}
/**
 * Transcription object.
 */
export interface RealtimeMessageResultTranscription {
  /**
   * Transcription text.
   */
  transcription: string;
  /**
   * Whether the transcription is final or partial.
   */
  isFinal: boolean;
  /**
   * Start time in milliseconds for the transcription text.
   */
  startTimeInMs: number;
  /**
   * End time in milliseconds for the transcription text.
   */
  endTimeInMs: number;
  /**
   * Confidence for the transcription text.
   */
  confidence: number;
  /**
   * Trailing silence after the transcription text.
   */
  trailingSilence: number;
  /**
   * Array of individual transcription tokens.
   */
  tokens: Array<RealtimeMessageResultTranscriptionToken>;
}

/**
 * Individual transcription tokens.
 */
export interface RealtimeMessageResultTranscriptionToken {
  /**
   * Transcription token.
   */
  token: string;
  /**
   * Start time in milliseconds for the transcription token.
   */
  startTimeInMs: number;
  /**
   * End time in milliseconds for the transcription token.
   */
  endTimeInMs: number;
  /**
   * Confidence score for the transcription token.
   */
  confidence: number;
  /**
   * Type of the transcription token.
   */
  type: RealtimeMessageResultTranscriptionTokenTypeEnum;
}

export type RealtimeMessageResultTranscriptionTokenTypeEnum = "WORD" | "PUNCTUATION";

/**
 * Parameters to be sent to the realtime speech service over a websocket connection.
 */
export interface RealtimeParameters {
  /**
   * Audio encoding to use - audio/raw;rate=16000 - audio/raw;rate=8000 - audio/raw;rate=8000;codec=mulaw - audio/raw;rate=8000;codec=alaw
   */
  encoding?: string;
  /**
   * Toggle for ack messages.
   */
  isAckEnabled?: boolean;
  /**
   * Silence threshold for Realtime Speech partial results in milliseconds.
   */
  partialSilenceThresholdInMs?: number;
  /**
   * Silence threshold for Realtime Speech final results in milliseconds.
   */
  finalSilenceThresholdInMs?: number;
  /**
   * When enabled sets the amount of confidence required for latest tokens before returning them as part of a new partial result
   */
  stabilizePartialResults?: RealtimeParametersStabilizePartialResultsEnum;
  /**
   * Model Domain.
   */
  modelDomain?: RealtimeParametersModelDomainEnum;
  /**
   * Locale value as per given in [https://datatracker.ietf.org/doc/html/rfc5646]. - en-US: English - United States - es-ES: Spanish - Spain - pt-BR: Portuguese - Brazil - en-GB: English - Great Britain - en-AU: English - Australia - en-IN: English - India - hi-IN: Hindi - India - fr-FR: French - France - de-DE: German - Germany - it-IT: Italian - Italy
   */
  languageCode?: string;
  /**
   * If set to true, the service will not fail connection attempt if it encounters any issues that prevent the loading of all specified user customizations. Any invalid customizations will simply be ignored and connection will continue being established with the default base model and any remaining valid customizations. If set to false, if the service is unable to load any of the specified customizations, an error detailing why will be returned and the session will end.
   */
  shouldIgnoreInvalidCustomizations?: boolean;
  /**
   * Array of customization objects.
   */
  customizations?: Array<CustomizationInference>;
  /**
   * Configure punctuations in the generated transcriptions. Disabled by default. - NONE: No punctuation in the transcription response - SPOKEN: Punctuations in response only when verbally spoken - AUTO: Automatic punctuation in the response, spoken punctuations are disabled
   */
  punctuation?: RealtimeParametersPunctuationEnum;
}

export enum RealtimeParametersStabilizePartialResultsEnum {
  NONE = "NONE",
  LOW = "LOW",
  MEDIUM = "MEDIUM",
  HIGH = "HIGH",
}
export enum RealtimeParametersModelDomainEnum {
  GENERIC = "GENERIC",
  MEDICAL = "MEDICAL",
}
export enum RealtimeParametersPunctuationEnum {
  NONE = "NONE",
  SPOKEN = "SPOKEN",
  AUTO = "AUTO",
}
/**
 * The response from the realtime session token endpoint that creates the auth token to be used with the realtime speech service.
 */
export interface RealtimeSessionToken {
  /**
   * The session token (JWT) to be consumed by the websocket server. The token contains the session/tenant ID, as well as the expiry time.
   */
  token: string;
  /**
   * The session ID this token corresponds to. Provided for convenience, the session ID is already present in the JWT token.
   */
  sessionId: string;
  /**
   * Compartment ID that was used to create the token.
   */
  compartmentId: string;
  /**
   * Simple key-value pair that is applied without any predefined name, type or scope. Exists for cross-compatibility only. Example: `{\"bar-key\": \"value\"}`.
   */
  freeformTags?: { [key: string]: string };
  /**
   * Defined tags for this resource. Each key is predefined and scoped to a namespace. Example: `{\"foo-namespace-1\": {\"bar-key-1\": \"value-1\", \"bar-key-2\": \"value-2\"}, \"foo-namespace-2\": {\"bar-key-1\": \"value-1\", \"bar-key-2\": \"value-2\"}}`.
   */
  definedTags?: { [key: string]: { [key: string]: any } };
}

/**
 * The websocket ack message received from service.
 */
export interface RealtimeMessageAckAudio extends RealtimeMessage {
  details: RealtimeMessageAckAudioDetails;
}

/**
 * The payload for credential-based authentication.
 */
export interface RealtimeMessageAuthenticationCredentials extends RealtimeMessageAuthentication {
  /**
   * The signed request header object.
   */
  headers: { [key: string]: string };
}

/**
 * The payload for JWT based authentication.
 */
export interface RealtimeMessageAuthenticationToken extends RealtimeMessageAuthentication {
  /**
   * The token (JWT) obtained from the realtime transcription session endpoint.
   */
  token: string;
}

/**
 * The websocket connection message received from service.
 */
export interface RealtimeMessageConnect extends RealtimeMessage {}

/**
 * The websocket error message received from service.
 */
export interface RealtimeMessageError extends RealtimeMessage {
  /**
   * Error code.
   */
  code: number;
  /**
   * Error message.
   */
  message: string;
}

/**
 * The websocket result message received from service.
 */
export interface RealtimeMessageResult extends RealtimeMessage {
  /**
   * List of transcription objects.
   */
  transcriptions: Array<RealtimeMessageResultTranscription>;
}

/**
 * Tell service to send final result
 */
export interface RealtimeMessageSendFinalResult extends RealtimeMessageOut {}
